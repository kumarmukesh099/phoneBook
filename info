  "bcryptjs": "^2.4.3",  // handle hashing and passwords because we should never store plain passwords
    "config": "^3.3.2", //for making available as global variable
    "express": "^4.17.1", //  web framework handle routing
    "express-validator": "^6.6.1", //use to validate the body like email passwords
    "jsonwebtoken": "^8.5.1", //use it for authentication 
    "mongoose": "^5.10.9",  // we can add delete and other things and create schema and all

    in config , we have everything which is available for everything
    default.json - access to it in our entire project

  It is important to have models in our app which define what type of structure of data your app consists or we can say in models we defines schema

  Define a schema and use it :  create its structure using mongoose.schema({}) 
                                then mongoose.models where we define the model name and schema name and
                                then we can assign value to it using new Schema and then save it


  We are creating a folder middleware where we authenticate everytime whenever we access some private routes means a logged in user want to access his/her profile

  whenever we have a middlewarefunction we use to do next to exceute the next middlewarefunction


  to use normal form-data
  const multiparty = require('multiparty');

app.post('/user-form-post', (req,res) =>{

   let form = new multiparty.Form();

   form.parse(req, function(err, fields, files) {
      Object.keys(fields).forEach(function(name) {
           console.log('got field named ' + name);
       });
   });
})

//install react app
npm create-react-app foldername

to run react concurrently

  "scripts": {
    "test": "node server.js",      //to run the normal nodejs server
    "start" : "nodemon server.js",  //to run the normal nodemon server
    "client" : "npm start --prefix client",  //to run the react server in client folder
    "clientinstall": "npm start  --prefix client", //to install the things in client folder
    "dev": "concurrently \npm run start\" \"npm run client\"" to run the react and node concurrently
  },

  //to run react normally we use npm start

  //we add proxy in react so that instead of using http://localhost:5000 we can directly use the localhost


  install it in client folder while using react axios , react-router-dom for router , switches and route and uuid(id generator) for dealing with db and 
  react-transition-group


import PropTypes from 'prop-types'
  Navbar.propTypes = {
    title : PropTypes.string.isRequired
}
Navbar.defaultProps = {
    title : 'Contact PhoneBook'
}
this is the way to use propTypes



   <Switch>   //Now, if we’re at /about, <Switch> will start looking for a matching <Route>. <Route path="/about"/> will match and <Switch> will stop looking for matches and render <About>. Similarly, if we’re at /user then <user> will render.
          <Route exact path="/" component={Home} /> //if we will not use exact then switch check /and will not check the next one
          <Route exact path="/About" component={About} />
        </Switch>


  //Context we have four files
  Folder > contactContext.js(Just to initialise the context) contactReducer.js contactState.js 
  and types.js

  We use contactState to use in app.js and use contactContext to use the value in other place

import ContactContext from './contactContext';
import ContactReducer from './contactReducer'; //should be in capital letters

{type.charAt(0).toUpperCase() + type.slice(1)} //chartAt(0) get the first letter and then Uppercase make it uppercase and then slice take rest of the letters in slice(start) 